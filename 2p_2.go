/*
	Работаем с двумя указателями. Фиксируем r и двигаем его. В момент, когда сумма в подмассиве lr станет больше s, двигаем l.
	На каждой итерации r добавляем к ответу кол-во новых уникальных отрезков, заканчивающихся в r.
*/

package main

import "fmt"

func main() {
	a := []int{9, 7, 6, 5, 8, 4}
	n := 6
	s := 20

	x := GoodSubstr(a, n, s)
	fmt.Println(x) // выводит 14
}

func GoodSubstr(a []int, n, s int) int {

	ans := 0

	l := 0
	// сумма в подмассиве lr
	sum := 0

	// фиксируем правую границу r
	for r := 0; r < n; r++ {

		// текущая сумма всех чисел в подмассиве lr прибавилась на a[r]
		sum += a[r]

		// проверяем, чтобы сумма чисел не превышала s. Двигаем левую границу, если превышает.
		for sum > s {

			sum -= a[l]
			l++

		}

		// прибавляем к ответу НОВЫЕ УНИКАЛЬНЫЕ подотрезки (чтобы несколько раз не считать одни и те же). Новые только те, которые заканчиваются в r.
		// Поэтому считаем, что можно сделать отрезки до r из любой точки массива lr (в т.ч. из r в r).
		ans += r - l + 1

	}

	return ans
}
