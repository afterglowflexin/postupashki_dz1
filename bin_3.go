/*
	Использую бин поиск по ответу. Задача аналогичная той, которую разбирали на лекции. Бинарю значение mult и ищу кол-во произведений i*j,
	которое меньше mid. Сравниваю кол-во этих произведений с k. Последнее кол-во произведений, которое удовлетворяет >=k будет как раз равно k и это будет равнятся k-му произведению.
*/

package main

import "fmt"

func main() {
	n := 3
	k := 5

	fmt.Println(FindMult(n, k)) // 3
}

func FindMult(n, k int) int {

	l := 0
	r := 10000000000 + 1

	ans := 0

	for l <= r {
		mid := (l + r) >> 1

		if Num(n, mid) >= k {
			r = mid - 1
			ans = mid
		} else {
			l = mid + 1
		}
	}

	return ans
}

// принимает число n и аргумент mult. Возвращает, сколько есть пар i*j <= mult, где 1 <= i,j <= n
func Num(n, mult int) int {
	l := 1
	r := n

	ans := 0

	// двигаем указатель r с конца вправо
	for r >= 1 {
		// для r находим первый l, для которого r*l > mult
		for r*l <= mult {
			l++

			// если l уже вышел за границы, выходим из цикла
			if l == n+1 {
				break
			}
		}

		// к ответу прибавляем l-1, потому что l - это первый элемент, для которого не выполняется условие, значит остальные l-1 элементов подходят
		ans += l - 1

		// сдвигаем r
		r--
	}

	return ans
}
