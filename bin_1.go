/*
	Не решил задачу. Не понимаю, как с бин поиском сделать адекватную асимптотику, если можно сделать O(n) без него, найдя сколько раз максимально встречается одно число,
	и вычесть из длины массива это число. Либо можно отсортировать массив и с помощью двух указателей тоже за O(n) найти самую длинную последовательность чисел (в этом случае
	не нужно использовать лишнюю память).

	Пытался бинарить по ответу. Идея следующая: r - максимум чисел, который надо потенциально удалить. Максимально он может быть n-1.
	l соответственно 0. В бин поиске с помощью вспомогательной функции проверяю достаточно ли удалить mid чисел, чтобы остались только равные.

	Не понимаю, как сделать правильный бин поиск. В моем варианте непонятно, зачем использовать бин поиск, если можно найти число, встречающееся большее число раз,
	и вычесть его количество из длины массива. Таким образом асимптотика будет O(n), но, конечно, надо будет выделить большую map'y или массив.
*/

package main

import (
	"fmt"
	"sort"
)

func main() {
	a := []int{1, 2, 1, 2, 3, 3, 5, 3, 1, 3}
	n := 10

	fmt.Println(MinToDelete(a, n))
}

func MinToDelete(a []int, n int) int {
	sort.Ints(a)

	l := 0
	r := n - 1

	ans := 0

	for l <= r {
		mid := (l + r) >> 1

		if Ok(a, mid) {
			r = mid
			ans = mid
		} else {
			l = mid + 1
		}
	}

	return ans
}

// принимает отсортированный массив и число numToDel. Возвращает, можно ли, удалив numToDel чисел из массива, сделать так, чтобы все оставшиеся были равны.
func Ok(a []int, numToDel int) bool {

}
