/*
	Использую идею 2 указателей. Фиксируем r и проходимся им по первому массиву. На каждой итерации убеждаемся, что сумма всех
	элементов в подмассиве lr <= s. Если она больше s, двигаем l.

	Для каждого lr, удовлетворяющего sum(lr) <= s, считаем во втором массиве сумму чисел от l до r. Если эта сумма максимальна, записываем lr в ответ.
*/

package main

import "fmt"

func main() {

	n := 6
	s := 20

	a := []int{9, 7, 6, 5, 8, 4}
	b := []int{7, 1, 3, 6, 8, 3}

	fmt.Println(FindSubstr(a, b, n, s)) // вывод 3 5
}

func FindSubstr(a, b []int, n, s int) (int, int) {

	l := 0
	sum := 0
	// наибольший "вклад" из массива b
	highestImpact := -1
	ans := [2]int{-1, -1}

	// фиксируем r
	for r := 0; r < n; r++ {
		// увеличиваем сумму
		sum += a[r]

		// с помощью этого цикла гарантируем, что сумма чисел меньше s
		for sum > s {
			sum -= a[l]
			l++
		}

		// далее считаем "вклад" в массиве b для найденных l и r.
		impact := 0

		for i := l; i <= r; i++ {
			impact += b[i]
		}

		// если он больше максимального из уже найденных, в ответ записываем l,r
		if impact > highestImpact {
			ans = [2]int{l, r}
		}
	}

	return ans[0], ans[1]
}
